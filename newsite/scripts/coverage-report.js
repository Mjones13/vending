#!/usr/bin/env node

/**
 * Coverage Report Generator
 * Generates comprehensive test coverage reports with detailed analysis
 */

const fs = require('fs')
const path = require('path')
const { execSync } = require('child_process')

const COVERAGE_DIR = path.join(__dirname, '../coverage')
const REPORTS_DIR = path.join(__dirname, '../test-reports')

function ensureDirectoryExists(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true })
  }
}

function runCoverageReport() {
  console.log('ðŸ§ª Generating test coverage report...\n')
  
  try {
    // Run Jest with coverage
    execSync('npm test -- --coverage --watchAll=false', {
      stdio: 'inherit',
      cwd: path.join(__dirname, '..')
    })
    
    // Ensure reports directory exists
    ensureDirectoryExists(REPORTS_DIR)
    
    // Read coverage summary
    const coverageSummaryPath = path.join(COVERAGE_DIR, 'coverage-summary.json')
    
    if (fs.existsSync(coverageSummaryPath)) {
      const coverageSummary = JSON.parse(fs.readFileSync(coverageSummaryPath, 'utf8'))
      
      // Generate enhanced report
      generateDetailedReport(coverageSummary)
      
      // Check coverage thresholds
      checkCoverageThresholds(coverageSummary)
      
      console.log('\nâœ… Coverage report generated successfully!')
      console.log(`ðŸ“Š HTML Report: file://${path.join(COVERAGE_DIR, 'lcov-report/index.html')}`)
      console.log(`ðŸ“‹ Detailed Report: ${path.join(REPORTS_DIR, 'coverage-detailed.md')}`)
      
    } else {
      console.error('âŒ Coverage summary not found. Make sure tests ran successfully.')
      process.exit(1)
    }
    
  } catch (error) {
    console.error('âŒ Coverage report generation failed:', error.message)
    process.exit(1)
  }
}

function generateDetailedReport(coverageSummary) {
  const timestamp = new Date().toISOString()
  const total = coverageSummary.total
  
  const reportContent = `# Test Coverage Report

**Generated:** ${timestamp}

## Overall Coverage Summary

| Metric | Coverage | Threshold | Status |
|--------|----------|-----------|--------|
| Lines | ${total.lines.pct}% (${total.lines.covered}/${total.lines.total}) | 80% | ${total.lines.pct >= 80 ? 'âœ… Pass' : 'âŒ Fail'} |
| Functions | ${total.functions.pct}% (${total.functions.covered}/${total.functions.total}) | 80% | ${total.functions.pct >= 80 ? 'âœ… Pass' : 'âŒ Fail'} |
| Branches | ${total.branches.pct}% (${total.branches.covered}/${total.branches.total}) | 80% | ${total.branches.pct >= 80 ? 'âœ… Pass' : 'âŒ Fail'} |
| Statements | ${total.statements.pct}% (${total.statements.covered}/${total.statements.total}) | 80% | ${total.statements.pct >= 80 ? 'âœ… Pass' : 'âŒ Fail'} |

## File Coverage Details

${generateFileCoverageTable(coverageSummary)}

## Coverage Analysis

### High Coverage Files (>90%)
${getHighCoverageFiles(coverageSummary)}

### Needs Attention (<80%)
${getLowCoverageFiles(coverageSummary)}

### Critical Files Coverage
${getCriticalFilesCoverage(coverageSummary)}

## Recommendations

${generateRecommendations(coverageSummary)}

## Testing Commands

\`\`\`bash
# Run tests with coverage
npm run test:coverage

# Run specific file tests
npm test -- ComponentName.test.tsx

# Run tests in watch mode
npm run test:watch

# View HTML coverage report
open coverage/lcov-report/index.html
\`\`\`

---
*Report generated by automated testing framework*
`

  fs.writeFileSync(
    path.join(REPORTS_DIR, 'coverage-detailed.md'),
    reportContent
  )
}

function generateFileCoverageTable(coverageSummary) {
  const files = Object.keys(coverageSummary).filter(key => key !== 'total')
  
  if (files.length === 0) {
    return 'No individual file coverage data available.'
  }
  
  let table = '| File | Lines | Functions | Branches | Statements |\n'
  table += '|------|-------|-----------|----------|-----------|\n'
  
  files.forEach(file => {
    const coverage = coverageSummary[file]
    const fileName = path.basename(file)
    table += `| ${fileName} | ${coverage.lines.pct}% | ${coverage.functions.pct}% | ${coverage.branches.pct}% | ${coverage.statements.pct}% |\n`
  })
  
  return table
}

function getHighCoverageFiles(coverageSummary) {
  const files = Object.keys(coverageSummary)
    .filter(key => key !== 'total')
    .filter(file => coverageSummary[file].lines.pct >= 90)
    .map(file => `- ${path.basename(file)}: ${coverageSummary[file].lines.pct}% lines`)
  
  return files.length > 0 ? files.join('\n') : 'No files with >90% coverage yet.'
}

function getLowCoverageFiles(coverageSummary) {
  const files = Object.keys(coverageSummary)
    .filter(key => key !== 'total')
    .filter(file => coverageSummary[file].lines.pct < 80)
    .map(file => `- ${path.basename(file)}: ${coverageSummary[file].lines.pct}% lines - Needs improvement`)
  
  return files.length > 0 ? files.join('\n') : 'All files meet minimum coverage threshold! ðŸŽ‰'
}

function getCriticalFilesCoverage(coverageSummary) {
  const criticalFiles = ['components/Layout.tsx', 'pages/index.tsx']
  
  return criticalFiles.map(file => {
    const coverage = coverageSummary[file]
    if (coverage) {
      return `- ${path.basename(file)}: ${coverage.lines.pct}% lines (Target: 85-90%)`
    } else {
      return `- ${path.basename(file)}: No coverage data - needs tests!`
    }
  }).join('\n')
}

function generateRecommendations(coverageSummary) {
  const recommendations = []
  const total = coverageSummary.total
  
  if (total.lines.pct < 80) {
    recommendations.push('ðŸ“ **Add more unit tests** - Overall line coverage is below 80% threshold')
  }
  
  if (total.functions.pct < 80) {
    recommendations.push('ðŸ”§ **Test more functions** - Function coverage needs improvement')
  }
  
  if (total.branches.pct < 70) {
    recommendations.push('ðŸŒ¿ **Add conditional testing** - Branch coverage indicates missing edge case tests')
  }
  
  const lowCoverageCount = Object.keys(coverageSummary)
    .filter(key => key !== 'total')
    .filter(file => coverageSummary[file].lines.pct < 80).length
  
  if (lowCoverageCount > 0) {
    recommendations.push(`ðŸ“ **Focus on low coverage files** - ${lowCoverageCount} files below 80% coverage`)
  }
  
  if (recommendations.length === 0) {
    recommendations.push('ðŸŽ‰ **Great job!** - All coverage metrics meet or exceed thresholds')
    recommendations.push('ðŸš€ **Consider increasing thresholds** - You might be ready for stricter coverage requirements')
  }
  
  return recommendations.join('\n')
}

function checkCoverageThresholds(coverageSummary) {
  const total = coverageSummary.total
  const thresholds = {
    lines: 80,
    functions: 80,
    branches: 80,
    statements: 80
  }
  
  const failures = []
  
  Object.keys(thresholds).forEach(metric => {
    if (total[metric].pct < thresholds[metric]) {
      failures.push(`${metric}: ${total[metric].pct}% (threshold: ${thresholds[metric]}%)`)
    }
  })
  
  if (failures.length > 0) {
    console.log('\nâš ï¸  Coverage threshold failures:')
    failures.forEach(failure => console.log(`   ${failure}`))
    console.log('\nðŸ’¡ Consider adding more tests to improve coverage.')
  } else {
    console.log('\nâœ… All coverage thresholds met!')
  }
}

// Run the coverage report if this script is executed directly
if (require.main === module) {
  runCoverageReport()
}

module.exports = {
  runCoverageReport,
  generateDetailedReport
}